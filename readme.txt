*软件项目开发管理流程：
·瀑布模型：作为在20世纪70年代、80年代盛极一时的软件开发模型，瀑布模型通过制定计划、需求分析、软件设计、程序编写、软件测试、运行维护等6个流程将整个软件生命周期衔接起来。这6个流程有着严格的先后次序之分，只有当前面的流程结束之后，下一个流程才能开始运转。这种自上而下的流程像极了瀑布的下落，因此得名瀑布模型
·敏捷开发：敏捷开发采用“迭代开发”，将软件项目需求分成多个迭代，且每个迭代成果在完成开发、测试、反馈等环节后都可以进行交付。也就是说，在将软件交付到客户手中之前，开发过程中的任何经过测试的子项目都能够独立运行。敏捷开发强调：个体和互动高于流程和工具、工作的软件高于详尽的文档、客户合作高于合同谈判、响应变化高于遵循计划
·DevOps：敏捷开发极大地提高了软件开发的速度，但它注重的是软件的开发阶段，并未兼顾到运维阶段。在开发人员与运维人员进行交接的时候，并没有体现出敏捷的价值、原则，因此开发与运维之间仍缺乏一些必要的协作效率。这时DevOps就应运而生，DevOps促进开发、运维、测试之间的高效协同，从而做到用持续软件交付来修复并能够更快地解决问题
·文档：
  -- 《软件开发流变史：从瀑布开发到敏捷开发再到DevOps》：https://zhuanlan.zhihu.com/p/222117833


*高质量的前端软件和高质量的前端代码
·高质量软件：
  -- 软件无bug：在满足软件所有需求功能基础上运行无bug
     -- 功能正常运行：包括功能性（含性能指标）、安全性、易用性、美观性、兼容性等
     -- 够健壮：在极端情况下软件也有相应处理机制，例如断网、设备性能低、极端尺寸下屏幕UI适配、数据异常等
     -- 性能高：在满足功能和性能指标基础上，软件性能尽可能高
  -- 软件开发周期短
     -- 软件能尽快满足客户需求
     -- 软件能够根据客户需求变化快速迭代
  -- 软件成本低
     -- 开发成本低
     -- 维护成本低
·高质量代码：在满足软件所有需求功能基础上运行无bug且开发效率高、代码性能高、代码风险小（bug风险、效率风险、可行性风险），具体可通过以下几个方面实现：
  -- 代码够健壮
  -- 代码易测试
  -- 代码易阅读
  -- 代码易扩展
  -- 代码易复用
  -- 代码性能高
·高质量代码与高质量软件的关系：
  -- 编写高质量的代码的目的是为了提高软件的质量
  -- 高质量的代码能够使产品迭代周期更短
  -- 高质量的代码可能会导致软件开发周期变长
  -- 编写高质量的代码通常能使软件质量提高，但是也可能使软件的部分方面的质量降低，例如提高软件可拓展性需要为未来的代码设置拓展点从而延长软件开发周期。所以需要提高软件质量要根据实际情况进行权衡哪些方面可以忽略一定的代码质量


*代码够健壮：
·对非常规情形进行了针对性处理
·对代码健壮性的最基本要求是：遇到异常不崩溃
·常见的异常类型：
  -- SyntaxError：语法错误
     语法错误也称为解析错误，语法错误在任何编程语言中都是最常见的错误类型，表示不符合编程语言的语法规范。js编译器的代词法分析阶段将字符流转换为记号流token，语法分析阶段会将记号流生成抽象语法树AST（详情见：https://github.com/jacksplwxy/JavaScript-compiler）。在这两个阶段，如果 Javascript引擎发现了预期之外/无法抓换的 token，或者 token 顺序和预期不一致时，就会抛出 SyntaxError。此类异常发生在JavaScript 解析/编译时，此类异常一旦发生，导致整个js文件都无法执行，而其他异常发生在代码运行时，这一类的错误会导致在错误出现的那一行之后的代码无法执行，但在那一行之前的代码不会受到影响。
     -- 对象中属性之间无逗号
     -- 多了大括号或者少了大括号等
     -- JSON.parse(function(){})
  -- TypeError：类型错误
     运行时最常见的异常，表示变量或参数不是预期类型。
     TypeError和ReferenceError的区别：ReferenceError就是在作用域中找不到，TypeError是在作用域中找到了但是做了它不可能做的事情
     例如：
     -- new关键字后面必须为构造函数
        let Dog='gg'
        new Dog()
     -- ()前必须为函数。如：
        let getName='gg'
        getName()
     -- 试图获取undefined、null的属性
        console.log(null.name)
     -- 预判错误的类型
        let a
        console.log(a.b)
        或
        let a={}
        console.log(a.getName())
  -- ReferenceError：引用错误
     引用一个不存在的变量时发生的错误，每当我们创建或定义一个变量时，变量名称都会写入一个变量存储中心中。这个变量存储中心就像键值存储一样，每当我们引用变量时，它都去存储中找到Key并提取并返回Value，如果我们要找的变量不在存储中，就会抛出ReferenceError。
     TypeError和ReferenceError的区别：ReferenceError就是在作用域中找不到，TypeError是在作用域中找到了但是做了它不可能做的事情
     -- 上下文中不存在的变量：
        console.log(jacksplwxy)
     -- 外部资源没有被正确载入:
        Uncaught ReferenceError: $ is not defined 就是因为jQuery没有正确导入而导致的
  -- RangeError：边界错误
     表示超出有效范围时发生的异常，主要的有以下几种情况：
     -- 数组长度为负数或超长
     -- 数字类型的方法参数超出预定义范围
     -- 函数堆栈调用超过最大值
  -- URIError：URL错误
　　 在调用URI相关的方法中URL无效时抛出的异常，主要包括encodeURI、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape(）几个函数
  -- EvalError:错误的使用了Eval 
  -- Error：所有错误的父类型
     抛出自定义错误:throw new Error("提示文字")
·异常的产生原因：
  -- 输入数据与预期的不一致
  -- 输入数据的来源：
     -- 各种IO数据
        -- 网络数据：由服务器响应决定
        -- 数据库数据：源数据异常、读取异常、读取超时等
        -- 文件数据：源数据异常、路径异常等
     -- 第三方库异常
     -- 函数参数异常
·如何保证代码遇到异常不崩溃
  -- 分析：js是单线程执行，为保证执行效率又加入eventLoop机制，主线程不断的循环往复的从任务队列中读取任务。其中任务分为主任务和异步任务，不同任务中发生代码异常不会影响到其他任务继续执行，只会影响同个任务中的异常后面的代码执行。
     另外，如果有语法异常，js在编译时就会报错，整个代码都不会运行，不过语法错误通常都会被ide提示出来
  -- 由于异步任务的执行依赖于主任务的执行，所以首先要保证主任务代码的健壮性，如此才能保证主流程畅通。虽然js能够很好地容错，但在一些情况下还是出现异常而导致程序终止运行
  -- 异步任务也可能影响主流程：
     例如页面弹窗后出现异常导致关闭按钮无法正常执行，从而导致弹窗影响页面其他的交互操作。
  -- 避免异常导致崩溃的办法汇总：
     -- 对第三方数据源如IO数据、第三方库的数据进行检验，可以通过throw主动抛出异常
     -- 需对参数进行校验，可以通过throw主动抛出异常
     -- 在处理JSON.parse()时，一定要用try/catch包起来
     -- 使用&&检验数据或方法的可用性：res&&res.data&&res.data.name


*代码性能高
·在功能（含性能指标）满足客户情况下，各种性能指标尽可能高
·前端的主要性能指标包括这些方面：
  -- 资源请求速度尽量快：从发送请求到接受到响应的时间间隔尽量短
  -- 首次渲染时间尽量短：即页面第一次有内容呈现的时间
  -- 页面加载时间尽量短：即页面所有资源加载完成时间
  -- 交互动作的反馈时间尽量快：即用户与网页交互时的事件响应快慢
  -- 帧率FPS不低于60帧
·提高代码性能更多内容：
  《FrontEndPerformanceOptimization》：https://github.com/jacksplwxy/FrontEndPerformanceOptimization


*代码易测试


*代码易阅读：
·编写高类聚低耦合的代码：
  -- 依赖性：单向依赖，当需要双向时增加一层抽象
  -- 正交性：一个模块提供的API中，多个方法之间是否有重复的功能
  -- 紧凑性：一个模块提供的API中，公有方法总数必须很少，每个方法的参数也必须很少
·代码风格统一
·代码注释详细，准确
  -- 满篇的注释并不是好代码，也不是好习惯，好的代码是不需要注释的
  -- 没有文档比错误的文档更好
·架构配置文档
·良好的变量名
·采用静态语言，明确数据类型
·减少hack、补丁、奇技淫巧，采用更普遍的工程代码
·对hack、补丁、奇技淫巧进行详细说明
·重复性的代码进行代码复用处理，使代码更简洁，易读
·良好的文件结构，功能相似的代码整理分类
·良好的分层结构，将多变与少变甚至不变的代码分开处理
·良好的代码结构，一类的或相似的变量用对象或数组归纳起来
·严禁枚举使用数字，必须使用有语义的字符
·代码不要超过200行
·if else :不会把if-else重构成高质量代码的程序员，不是个优秀的程序员 - 打酱油的程序媛的文章 - 知乎
https://zhuanlan.zhihu.com/p/260731207

*代码易扩展：
·编写易扩展的关键是熟悉产品业务，为需要扩展的地方预留扩展点
·实现预留扩展点的关键是：对代码进行适当抽象。抽象将具有更大的通用性或者兼容性，如此实现扩展
·对于js，怎样编码能使代码具有很好的可扩展性
  -- js的对象有较好可扩展性
  -- js的数组有较好可扩展性
  -- ts的枚举
  -- 函数的参数：参数的改变可以导致函数运行结果的变化。
  -- js中的原型：继承可以改变被继承类的成员变量和方法。类似的还要java中的继承
  -- 接口或抽象类：能使类更加抽象，使代码具有通用性
  -- vue中的插槽(slot):通过在slot中输入不同的内容，可以改变组件的显示


*代码易复用：
·代码复用的好处：
  -- 复用代码一次编写，到处调用，十分方便高效
  -- 复用代码一次修改，到处改变，十分方便高效
  -- 可以防止未复用时漏修改的问题，十分安全可靠
  -- 代码整体更加简洁，可阅读性增强
  -- 降低软件开发风险，包括bug风险、效率风险
·代码复用的坏处：
  -- 代码的复用通常需要进行一定的抽象，逻辑不直观，较大的增加编码难度和时间
  -- 代码复用后，通常需要单独提取出来保管，文件结构更复杂，依赖更多，破坏代码整体连贯性，增加维护难度
  -- 代码复用后，耦合增强，当需要兼容更多情况时，代码将变复杂，将增加维护难度。因为如果不复用，则可以直观修改各自逻辑即可。
·代码何时需要复用：
  -- 提前对整个业务流程进行学习掌握，编码时对已知需要复用的或者存在非常大可能性需要复用的代码进行复用处理。
  -- 编码过程中，简单逻辑重复出现3次或更多次数时，对代码进行复用处理。
  -- 编码过程中，复杂逻辑重复出现2次或更多次数时，对代码进行复用处理。
·代码复用的实现手段：
  -- js中的原型对象：所有引用原型的对象都将复用原型对象的属性和方法
  -- java中的类：类的实例都拥有类的成员变量和方法
  -- java中类的继承
  -- 函数
  -- vue中的组件：组件可以被引入到其他组件中实现复用
  -- vue中的混入(mixin)：mixin可分发vue组件中的可复用功能
  -- vue中的指令
  -- vue中的插件
  -- vuex
  -- 订阅发布






